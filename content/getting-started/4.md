---
title: 4. Configuring your Application
---

So far we've [installed Kubernetes](/getting-started), [run our first app](/getting-started/1), learned how to [scale that app](/getting-started/2) and [exposed that application](/getting-started/3) via a service.

You may want to pass configuration settings into your application, you can use **Config Maps** and **Secrets** to do this.

## Do

### Create a basic website

Create a HTML file to display hello world:

```console
echo '<html><head><title>Hello World</title></head><body>Hello World</body></html>' > /tmp/index.html
```

### Create a Config Map

Create a Kubernetes Config Map from that file:

```console
$kubectl create configmap hello --from-file=/tmp/index.html
configmap/hello created
```

### Create a Secret

Create a Kubernetes Secret from that file:

```console
$ kubectl create secret generic hello --from-file=/tmp/index.html
secret/hello created
```

View the resultant Config Map:

```yaml
$ kubectl get configmap hello -o yaml
apiVersion: v1
data:
  index.html: |
    <html><head><title>Hello World</title></head><body>Hello World</body></html>
kind: ConfigMap
metadata:
  creationTimestamp: "2019-08-15T20:09:43Z"
  name: hello
  namespace: default
  resourceVersion: "591027"
  selfLink: /api/v1/namespaces/default/configmaps/hello
  uid: a47a6058-a482-40be-99d3-1aaf5390af85
```

View the resultant Secret:

> Note: the secret is unreadable. It is not encrypted, simple base64 encoded.

```yaml
apiVersion: v1
data:
  index.html: PGh0bWw+PGhlYWQ+PHRpdGxlPkhlbGxvIFdvcmxkPC90aXRsZT48L2hlYWQ+PGJvZHk+SGVsbG8gV29ybGQ8L2JvZHk+PC9odG1sPgo=
kind: Secret
metadata:
  creationTimestamp: "2019-08-15T20:09:49Z"
  name: hello
  namespace: default
  resourceVersion: "591038"
  selfLink: /api/v1/namespaces/default/secrets/hello
  uid: ead44f8c-041f-4db7-bb98-ee56dd1f2e3e
type: Opaque
```

You can map either of these into your **Pod** as an environment variable, or as a file in a volume. Since the example application is nginx it makes sense to mount it as a file in a volume.

To mount it as a volume you would need to edit the actual underlying Kubernetes manifest defining the Deployment. You could do this live with the `kubectl edit` command, however it will be easier if we create a new **pod** from a simpler manifest.

### Create a new deployment

Create the following file as `/tmp/hello.yaml`:

```yaml
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: hello-world
spec:
  selector:
    matchLabels:
      app: hello-world
  template:
    metadata:
      labels:
        app: hello-world
    spec:
      containers:
      - name: hello
        image: nginx:latest
        volumeMounts:
        - name: html
          mountPath: /usr/share/nginx/html
      volumes:
      - name: html
        configMap:
          name: hello
```

Apply that manifest using the declarative command `kubectl apply`:

```console
$ kubectl apply -f /tmp/hello.yaml
deployment.extensions/hello-world created
```

### Test the new deployment

Use `kubectl port-forward` to enable access to the new deployment:

```console
$ kubectl port-forward deployment/hello-world 8080:80
Forwarding from 127.0.0.1:8080 -> 80
Handling connection for 8080
```

Access the new port-forward from another terminal (or from a web browser):

```console
$ curl localhost:8080
<html><head><title>Hello World</title></head><body>Hello World</body></html>
```

## Learn
